#!/usr/bin/env python3
import argparse
import re
from pathlib import Path


def load_wiring(wiring_file: Path):
    status_map = {}
    wiring_map = {}
    notes_map = {}
    if not wiring_file.exists():
        return status_map, wiring_map, notes_map

    for line in wiring_file.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("|")
        fqn = parts[0].strip()
        status = parts[1].strip() if len(parts) > 1 else "unknown"
        wiring = parts[2].strip() if len(parts) > 2 else ""
        notes = parts[3].strip() if len(parts) > 3 else ""
        status_map[fqn] = status or "unknown"
        wiring_map[fqn] = wiring
        notes_map[fqn] = notes
    return status_map, wiring_map, notes_map


def find_contracts(repo_root: Path):
    contract_dirs = [
        repo_root / "modules/core/api/src/main/java",
        repo_root / "modules/core/spi/src/main/java",
    ]
    contracts = []

    package_re = re.compile(r"^package\s+([a-zA-Z0-9_.]+);")
    decl_re = re.compile(r"public\s+(class|interface|enum|record)\s+([A-Za-z0-9_]+)")

    for base_dir in contract_dirs:
        if not base_dir.exists():
            continue
        for path in sorted(base_dir.rglob("*.java")):
            package_name = None
            kind = None
            name = None
            for line in path.read_text(encoding="utf-8").splitlines():
                if package_name is None:
                    match = package_re.match(line.strip())
                    if match:
                        package_name = match.group(1)
                if kind is None:
                    match = decl_re.search(line)
                    if match:
                        kind = match.group(1)
                        name = match.group(2)
                if package_name and kind and name:
                    break
            if not package_name or not kind or not name:
                continue
            fqn = f"{package_name}.{name}"
            relative_path = path.relative_to(repo_root).as_posix()
            module_kind = "api" if "modules/core/api/" in relative_path else "spi"
            contracts.append((fqn, kind, module_kind, relative_path))
    contracts.sort(key=lambda item: item[0])
    return contracts


def format_output(contracts, status_map, wiring_map, notes_map):
    total_count = len(contracts)
    wired_count = 0
    partial_count = 0
    not_wired_count = 0
    unknown_count = 0

    for fqn, _, _, _ in contracts:
        status = status_map.get(fqn, "unknown")
        if status == "wired":
            wired_count += 1
        elif status == "partial":
            partial_count += 1
        elif status == "not_wired":
            not_wired_count += 1
        else:
            unknown_count += 1

    lines = []
    lines.append("# Contract Index (Auto-generated)")
    lines.append("")
    lines.append("This file is auto-generated by `tools/scripts/update_contract_index.sh`.")
    lines.append("Do not edit by hand.")
    lines.append("")
    lines.append("## Summary")
    lines.append(f"- Total contracts: {total_count}")
    lines.append(f"- Wired: {wired_count}")
    lines.append(f"- Partially wired: {partial_count}")
    lines.append(f"- Not wired: {not_wired_count}")
    lines.append(f"- Unknown: {unknown_count}")
    lines.append("")
    lines.append("## Contracts")

    for fqn, kind, module_kind, relative_path in contracts:
        status = status_map.get(fqn, "unknown")
        wiring = wiring_map.get(fqn, "")
        notes = notes_map.get(fqn, "") or "(none)"
        if wiring:
            wiring_paths = [p.strip() for p in wiring.split(";") if p.strip()]
            wiring_formatted = ", ".join(f"`{p}`" for p in wiring_paths)
        else:
            wiring_formatted = "(none)"

        lines.append("")
        lines.append(f"### {fqn} ({module_kind} {kind})")
        lines.append(f"- Source: `{relative_path}`")
        lines.append(f"- Capabilities Matrix: wiring={status}; paths={wiring_formatted}; notes={notes}")

    return "\n".join(lines) + "\n"


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--check", action="store_true", help="Verify contract index is up to date")
    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[2]
    index_file = repo_root / "docs/contracts/CONTRACT_INDEX.md"
    wiring_file = repo_root / "docs/contracts/contract_wiring.tsv"

    status_map, wiring_map, notes_map = load_wiring(wiring_file)
    contracts = find_contracts(repo_root)
    output = format_output(contracts, status_map, wiring_map, notes_map)

    if args.check:
        if not index_file.exists():
            raise SystemExit("Missing docs/contracts/CONTRACT_INDEX.md. Run tools/scripts/update_contract_index.sh")
        if index_file.read_text(encoding="utf-8") != output:
            raise SystemExit("docs/contracts/CONTRACT_INDEX.md is out of date. Run tools/scripts/update_contract_index.sh")
        return

    index_file.write_text(output, encoding="utf-8")


if __name__ == "__main__":
    main()
